There are a lot of complexities to the observer pattern that are hidden in languages like Java (they still exist, you just aren't forced to deal with them up front like you are in Rust).

First, there is the question of ownership: 
    Should the subject keep the observer alive as long as it exists? 
    Or should the observer just stop observing the subject at the end of its life? 
Often you want the latter, but Java makes it easy to accidentally get the former instead, because the latter requires the use of weak references - a somewhat advanced feature in Java.

In Rust, you have to choose: 
    for the former, you might use an owned pointer type, like a Box, Rc or Arc. 
    for the latter, you might use a Weak reference-counted type, or a normal &T reference if you can work with the lifetime constraints.

Second, there is the question of internal mutability: 
    in Java, all types are automatically internally mutable (hence the need for the "immutable class pattern"). Internal mutability is required because usually an observer wants to update its own state in response to a callback from the subject, but the subject doesn't have exclusive access to the observer.
In Rust, you would achieve this using a Cell, RefCell, Mutex, RwLock or other internally mutable type, depending on your requirements.

Third, there is the question of thread-safety: 
    in Java, if you subscribe to subjects on multiple threads, you will receive callbacks concurrently and this could result in the observer corrupting its own internal state. To avoid this, you would mark the observer's methods as "synchronized" so that there is a strict linear ordering to their calls.
In Rust, the compiler will prevent references to your observer from crossing thread boundaries, unless you use the appropriate thread-safe types. From the types I listed above, Rc, Cell and RefCell are all not thread-safe (they do not implement the Sync trait) and so if you use those types, your observer won't be able to subscribe to subjects on multiple threads, but on the other hand they come with less performance overhead. The types Mutex, RwLock and Arc are all thread-safe.
